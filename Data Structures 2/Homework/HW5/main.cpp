// =====================================================================
// =====================================================================
// NOTE: DO NOT EDIT THIS FILE EXCEPT WHERE INDICATED
// =====================================================================
// =====================================================================


#include <iostream>
#include <cassert>
#include <cstdlib>
#include <string>


// You will write the grid.h file to implement the Grid class and
// helper classes GridIterator and Node.
#include "grid.h"


// prototypes for helper testing functions
void test_example();
void test_iterators();
void test_separation();
void test_iterators_part_2();

void additional_student_tests();


// =====================================================================
// =====================================================================

int main(int argc, char* argv[]) {

  // =======================================================================
  // NOTE: UNCOMMENT THESE FUNCTIONS AS YOU WORK THROUGH YOUR IMPLEMENTATION
  // =======================================================================

  test_example();
  test_iterators();
  test_separation();
  test_iterators_part_2();

  additional_student_tests();

}

// =====================================================================
// =====================================================================

void test_example() {
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_example()" << std::endl;


  // ------------------------------
  // simple construction & printing
  std::cout << "\nA 5x1 horizontal row:" << std::endl;
  Grid<int> horizontal(5,1,42);
  horizontal.print();

  std::cout << "\nA 1x3 vertical column:" << std::endl;
  Grid<int> vertical(1,3,99);
  vertical.print();
  
  std::cout << "\nA 4x3 grid of zeros:" << std::endl;
  Grid<int> grid(4,3);
  assert (grid.getWidth() == 4);
  assert (grid.getHeight() == 3);
  assert (grid.getSize() == 12);
  grid.print();

  
  
  // --------------------------------------------
  // initializing and checking values by index
  // (rather inefficient for this data structure)
  std::cout << "\nNow let's initialize the grid values:" << std::endl;
  int tmp = 1;
  for (int j = 0; j < 3; j++) {
    for (int i = 0; i < 4; i++) {
      grid.set(i,j,tmp);
      tmp++;
    }
  }
  grid.print();
  assert (grid.get(0,0) == 1);
  assert (grid.get(0,1) == 5);
  assert (grid.get(2,2) == 11);


  // ----------------------
  // create basic iterators
  Grid<int>::iterator itr;
  itr = grid.begin_upper_left();
  assert (*itr == 1);
  itr  = grid.begin_upper_right();
  assert (*itr == 4);
  itr = grid.begin_lower_left();
  assert (*itr == 9);
  itr  = grid.begin_lower_right();
  assert (*itr == 12);
  

  // -------------------------------
  // combining grids: join and stack
  std::cout << "\nLet's join the vertical column on the right: " << std::endl;
  grid.join(vertical);
  assert (grid.getWidth() == 5);
  assert (grid.getHeight() == 3);
  assert (vertical.getWidth() == 0);
  assert (vertical.getHeight() == 0);
  grid.print();

  std::cout << "\nAnd stack the horizontal row on the top: " << std::endl;
  grid.stack(horizontal);
  assert (grid.getWidth() == 5);
  assert (grid.getHeight() == 4);
  assert (horizontal.getWidth() == 0);
  assert (horizontal.getHeight() == 0);
  grid.print();

  std::cout << "\ndone with test_example()" << std::endl;
    
}

// =====================================================================
// =====================================================================

void test_iterators() {

  
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_iterators()" << std::endl;
  
  std::cout << "\nA 4x3 grid of dots:" << std::endl;
  Grid<char> grid(6,4,'.');
  assert (grid.getWidth() == 6);
  assert (grid.getHeight() == 4);
  grid.print();

  std::cout << "\nUse an iterator to walk along a specific path in the grid:" << std::endl;
  Grid<char>::iterator itr  = grid.begin_lower_right();
  assert (*itr == '.');
  *itr = '0';
  itr.left();  *itr = '1';
  itr.up();    *itr = '2';
  itr.up();    *itr = '3';
  itr.left();  *itr = '4';
  itr.left();  *itr = '5';
  itr.left();  *itr = '6';
  itr.down();  *itr = '7';
  itr.right(); *itr = '8';
  itr.down();  *itr = '9';
  grid.print();

  
  std::cout << "\nReset all values in the grid to a specific value" << std::endl;
  grid.reset('?');
  grid.print();

  std::cout << "\nLabel by snaking horizontally through the grid:" << std::endl;
  char tmp = 'a';
  itr = grid.begin_snake();
  while (itr != grid.end_snake()) {
    assert (*itr == '?');
    *itr = tmp;
    tmp++;
    itr++;
  }
  grid.print();

  grid.clear();
  assert (grid.getSize() == 0);
  assert (grid.getWidth() == 0);
  assert (grid.getHeight() == 0);
    
  std::cout << "\ndone with test_iterators()" << std::endl;
  
}

// =====================================================================
// =====================================================================

void test_separation() {
  
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_separation()" << std::endl;

  std::cout << "\nPrepare an interesting grid:" << std::endl;
  Grid<int> grid(7,5);
  int tmp = 1;
  Grid<int>::iterator itr = grid.begin_snake();
  while (itr != grid.end_snake()) {
    assert (*itr == 0);
    *itr = tmp;
    tmp++;
    itr++;
  }
  grid.print();
  itr = grid.begin_upper_left();
  itr.right().right().down().down();
  assert (*itr == 17);


  std::cout << "\nLifting off the top:" << std::endl;
  Grid<int> top;
  assert (top.getSize() == 0 && top.getWidth() == 0 && top.getHeight() == 0);
  grid.lift(itr,top);
  top.print();

  std::cout << "\nLeaving the rest:" << std::endl;
  grid.print();
  assert (*itr == 17);


  std::cout << "\nChopping off the right:" << std::endl;
  Grid<int> side;
  grid.chop(itr,side);
  side.print();

  std::cout << "\nLeaving the rest:" << std::endl;
  grid.print();
  assert (*itr == 17);
  itr.right().down();
  assert (*itr == 25);

  
  std::cout << "\nJoin it back together on the other side:" << std::endl;
  side.join(grid);
  side.print();

  std::cout << "\nAnd stack on the top:" << std::endl;
  top.stack(side);
  top.print();
  assert (top.getWidth() == 7);
  assert (top.getHeight() == 5);
  assert (top.getSize() == 35);

  assert (*top.begin_upper_left()  == 17);
  assert (*top.begin_upper_right() == 16);
  assert (*top.begin_lower_right() == 8);
  assert (*top.begin_lower_left()  == 14);
  
  std::cout << "\ndone with test_separation()" << std::endl;
    
}

// =====================================================================
// =====================================================================

void test_iterators_part_2() {
  
  std::cout << "=====================================================================" << std::endl;
  std::cout << "test_iterators_part_2()" << std::endl;

  std::cout << "\nA 6x4 grid of _'s:" << std::endl;
  Grid<char> grid(6,4,'_');  
  grid.print();

  std::cout << "\nLabel by spiraling into the grid:" << std::endl;
  char tmp = 'A';
  Grid<char>::iterator itr = grid.begin_spiral();
  while (itr != grid.end_spiral()) {
	assert (*itr == '_');
    *itr = tmp;
    tmp++;
    itr++;
  }
  grid.print();


  std::cout << "\nAnd a larger example:" << std::endl;
  Grid<int> bigger(8,10,0);
  Grid<int>::iterator itr2 = bigger.begin_spiral();
  int tmp2 = 1;
  while (itr2 != bigger.end_spiral()) {
    *itr2 = tmp2;
    tmp2++;
    itr2++;
  }
  bigger.print();


  // walking off the board should hit the end iterator
  itr2 = bigger.begin_lower_left();
  assert (*itr2 == 24);
  itr2.right().right();
  assert (*itr2 == 22);
  itr2.down();
  assert (itr2 == bigger.end()); 

  itr2 = bigger.begin_upper_right();
  assert (*itr2 == 8);
  itr2.down().down();
  assert (*itr2 == 10);
  itr2.right();
  assert (itr2 == bigger.end());

  
  std::cout << "\nA dereferenced iterator can be an l-value (and modify data):" << std::endl;
  itr2 = bigger.begin_lower_right();
  itr2.up().left().up().left();
  assert (*itr2 = 65);
  *itr2 = 0;
  assert (bigger.get(5,7) == 0);

  itr2 = bigger.begin_snake();
  for (int i = 0; i < 19; i++) { itr2++; }
  assert (*itr2 = 58);
  *itr2 = -1;
  assert (bigger.get(3,2) == -1);
  
  bigger.print();
  
  std::cout << "\ndone with test_iterators_part_2()" << std::endl;
  
}  


// =====================================================================
// =====================================================================

void additional_student_tests() {

  std::cout << "=====================================================================" << std::endl;
  std::cout << "additional_student_tests()" << std::endl;
	
	std::cout << "\nA 3x7 grid:" << std::endl;
  Grid<int> grid1(4,7,78);
  grid1.print();

  std::cout << "\nA 7x3 grid:" << std::endl;
  Grid<int> grid2(7,3,18);
  grid2.print();
  
  std::cout << "\nA 3x7 grid of zeros:" << std::endl;
  Grid<int> grid(3,7);
  grid.print();

  
  
  // --------------------------------------------
  // initializing and checking values by index
  // (rather inefficient for this data structure)
  std::cout << "\nNow let's initialize the grid values:" << std::endl;
  int tmp = 1;
  for (int j = 0; j < 7; j++) {
    for (int i = 0; i < 3; i++) {
      grid.set(i,j,tmp);
      tmp++;
    }
  }
  grid.print();
  

  // -------------------------------
  // combining grids: join and stack
  std::cout << "\njoin: " << std::endl;
  grid.join(grid1);
  grid.print();

  std::cout << "\nstack: " << std::endl;
  grid.stack(grid2);
  grid.print();


  
  
  
  
  
  std::cout << "\nA 4x3 grid of a's:" << std::endl;
  Grid<char> grids(4,3,'a');
  grid.print();

  std::cout << "\nUse an iterator to walk along a specific path in the grid:" << std::endl;
  Grid<char>::iterator itr  = grids.begin_lower_right();
  *itr = '0';
  itr.left();  *itr = '1';
  itr.up();    *itr = '2';
  itr.up();    *itr = '3';
  itr.left();  *itr = '4';
  grids.print();

  
  std::cout << "\nReset all values in the grid to a specific value" << std::endl;
  grids.reset('z');
  grids.print();

  std::cout << "\nLabel by snaking horizontally through the grid:" << std::endl;
  char temp = 'a';
  itr = grids.begin_snake();
  while (itr != grids.end_snake()) {
    *itr = temp;
    tmp++;
    itr++;
  }
  grids.print();

  grids.clear();
  
  
  
  
  std::cout << "\nNew Grid:" << std::endl;
  Grid<int> gridd(9,5);
  int tmps = 12;
  Grid<int>::iterator itrs = gridd.begin_snake();
  while (itrs != gridd.end_snake()) {
    *itrs = tmps;
    tmps++;
    itrs++;
  }
  gridd.print();
  itrs = gridd.begin_upper_left();
  itrs.right().right().down().down();


  std::cout << "\nLifting off the top:" << std::endl;
  Grid<int> top;
  gridd.lift(itrs,top);
  top.print();

  std::cout << "\nLeaving the rest:" << std::endl;
  gridd.print();


  std::cout << "\nChopping off the right:" << std::endl;
  Grid<int> side;
  gridd.chop(itrs,side);
  side.print();

  std::cout << "\nLeaving the rest:" << std::endl;
  gridd.print();
  itrs.right().down();

  
  std::cout << "\nJoin it back together on the other side:" << std::endl;
  side.join(gridd);
  side.print();

  std::cout << "\nAnd stack on the top:" << std::endl;
  top.stack(side);
  top.print();
  
  
  
  
  
  
  
  std::cout << "\nA 9x8 grid of _'s:" << std::endl;
  Grid<int> gridds(9,8,0);  
  gridds.print();

  std::cout << "\nLabel by spiraling into the grid:" << std::endl;
  int tmpes = 32;
  Grid<int>::iterator itrd = gridds.begin_spiral();
  while (itrd != gridds.end_spiral()) {
    *itrd = tmpes;
    tmpes++;
    itrd++;
  }
  gridds.print();


  std::cout << "\nAnd a larger example:" << std::endl;
  Grid<int> bigger(8,14,2);
  Grid<int>::iterator itr2 = bigger.begin_spiral();
  int tmp2 = 1;
  while (itr2 != bigger.end_spiral()) {
    *itr2 = tmp2;
    tmp2++;
    itr2++;
  }
  bigger.print();


  // walking off the board should hit the end iterator
  itr2 = bigger.begin_lower_left();
  itr2.right().right();
  itr2.down();

  itr2 = bigger.begin_upper_right();
  itr2.down().down();
  itr2.right();

  
  std::cout << "\nA dereferenced iterator can be an l-value (and modify data):" << std::endl;
  itr2 = bigger.begin_lower_right();
  itr2.up().left().up().left();
  *itr2 = 0;

  itr2 = bigger.begin_snake();
  for (int i = 0; i < 20; i++) { itr2++; }
  *itr2 = -99;
  
  bigger.print();
  
  // =======================================================================
  // NOTE: WRITE YOUR OWN TEST CASES HERE!
  // =======================================================================



  std::cout << "done with additional_student_tests()" << std::endl;
}

// ======================================================================
// ======================================================================
